============================================
vis/jlafontaine-submit.txt
22:36:44_Wednesday_28_October_2020
============================================
============================================
=== Compiling with gcc -Wall -std=c99 -o ass2 *.c -lm
============================================
============================================
=== Static analysis with clang --analyze *.c
============================================
ass2.c:509:43: warning: Dereference of undefined pointer value
                                if ((*currentprecon)[i]==MUSTTRUE && !((*prevstate)[i])) {
                                                                      ^~~~~~~~~~~~~~~~~
ass2.c:513:49: warning: Dereference of undefined pointer value
                                }else if ((*currentprecon)[i]==MUSTFALSE && (*prevstate)[i]) {
                                                                            ^~~~~~~~~~~~~~~
ass2.c:625:1: warning: Potential leak of memory pointed to by 'canactions'
}
^
3 warnings generated.
============================================
=== Compilation finished
============================================
IMPORTANT  ---  IMPORTANT  ---  IMPORTANT
The final version of Assignment 2 must be
    submitted via the LMS. This service is 
    just so that you can test your code.
See the detailed instructions on the LMS.
============================================
=== Submission testing begins
=== test 1: ass2  < test0.txt
=== Output: differs from expectations
+|==STAGE 0===============================
+|Number of distinct actions: 3
+|Length of the input trace: 5
+|Trace status: valid
+|----------------------------------------
+|  abcdefghijklmnopqrstuvwxyz
+|> 11000000000000000000000111
+|X 10100100000000000000000111
+|V 10100100000000011000000111
+|U 10100100000000000000000111
+|V 10100100000000011000000111
+|U 10100100000000000000000111
============================================
=== test 2: ass2  < test1.txt
=== Output: differs from expectations
+|==STAGE 0===============================
+|Number of distinct actions: 3
+|Length of the input trace: 5
+|Trace status: invalid
+|----------------------------------------
+|  abcdefghijklmnopqrstuvwxyz
+|> 11000000000000000000000111
+|X 10100100000000000000000111
+|V 10100100000000011000000111
+|U 11100100000000000000000111
+|V 11100100000000011000000111
============================================
=== test 3: ass2  < test2.txt
=== Output: differs from expectations
+|==STAGE 0===============================
+|Number of distinct actions: 8
+|Length of the input trace: 10
+|Trace status: valid
+|----------------------------------------
+|  abcdefghijklmnopqrstuvwxyz
+|> 10000000000000000000000000
+|D 10000000000000000000000111
+|F 10000000000000000000100000
+|A 10000000000000000000100100
+|B 10000000000000000000100111
+|F 10000000000000000000100000
+|A 10000000000000000000100100
+|C 10000000000000000000100110
+|G 10000000110000000000100110
+|H 10000000000000000000100110
+|E 10000000000000000000100111
+|==STAGE 1===============================
+|Candidate routine: AB
+|    0: D
+|    2: AB
+|----------------------------------------
+|Candidate routine: D
+|    0: D
+|    2: AB
+|==STAGE 2===============================
+|Candidate routine: D
+|    0: D
+|    2: AB
+|    5: ACGHE
+|----------------------------------------
+|Candidate routine: AB
+|    0: D
+|    2: AB
+|    5: ACGHE
+|==THE END===============================
============================================
=== test 4: ass2  < test3.txt
=== Output: differs from expectations
+|==STAGE 0===============================
+|Number of distinct actions: 5
+|Length of the input trace: 78
+|Trace status: valid
+|----------------------------------------
+|  abcdefghijklmnopqrstuvwxyz
+|> 11111111111111111111111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|E 11111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|A 01111111111111101111111111
+|E 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|E 11111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|A 01111111111111111111111111
+|T 11111111111111111110111111
+|R 11111111111111111011111111
+|E 11111111111111111111111111
+|P 11111111111111101111111111
+|E 11111111111111111111111111
+|E 11111111111111111111111111
+|T 11111111111111111110111111
+|==STAGE 1===============================
+|Candidate routine: EA
+|    1: EPEA
+|    7: EPEA
+|   13: EPEA
+|   25: EPAE
+|   31: EPEA
+|   37: EPEA
+|   49: EPEA
+|   55: EPEA
+|   61: EPEA
+|   67: EPEA
+|----------------------------------------
+|Candidate routine: REPEAT
+|    0: REPEAT
+|    6: REPEAT
+|   12: REPEAT
+|   18: REPEET
+|   24: REPAET
+|   30: REPEAT
+|   36: REPEAT
+|   42: REPEET
+|   48: REPEAT
+|   54: REPEAT
+|   60: REPEAT
+|   66: REPEAT
+|   72: REPEET
+|----------------------------------------
+|Candidate routine: ET
+|   21: EET
+|   28: ET
+|   45: EET
+|   75: EET
============================================
=== test 5: ass2  < test4.txt
=== Output: differs from expectations
+|==STAGE 0===============================
+|Number of distinct actions: 6
+|Length of the input trace: 40
+|Trace status: valid
+|----------------------------------------
+|  abcdefghijklmnopqrstuvwxyz
+|> 00000000000000000000000000
+|D 00010000000000000000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|U 00000000000000100000000000
+|N 00000000000000000000000000
+|D 00010000000000000000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|R 11010000000000100000000000
+|E 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|R 11010000000000100000000000
+|E 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|U 00000000000000100000000000
+|N 00000000000000000000000000
+|R 11000000000000000000000000
+|E 00000000000000000000000000
+|D 00010000000000000000000000
+|O 00010000000000100000000000
+|D 00010000000000100000000000
+|O 00010000000000100000000000
+|==STAGE 1===============================
+|Candidate routine: DO
+|    0: DO
+|    2: DO
+|    4: DO
+|    6: UNDO
+|   10: DO
+|   12: DO
+|   14: DO
+|   16: DO
+|   18: DO
+|   22: DO
+|   26: DO
+|   28: DO
+|   30: DO
+|   36: DO
+|   38: DO
+|==STAGE 2===============================
+|Candidate routine: DO
+|    0: DO
+|    2: DO
+|    4: DO
+|    6: UNDO
+|   10: DO
+|   12: DO
+|   14: DO
+|   16: DO
+|   18: DO
+|   20: REDO
+|   24: REDO
+|   28: DO
+|   30: DO
+|   32: UNREDO
+|   38: DO
+|==THE END===============================
============================================
=== test 6: ass2  < test5.txt
=== Output: differs from expectations
+|==STAGE 0===============================
+|Number of distinct actions: 8
+|Length of the input trace: 30
+|Trace status: valid
+|----------------------------------------
+|  abcdefghijklmnopqrstuvwxyz
+|> 11100000000000000000000000
+|A 00000000000000000000000000
+|X 11100000000000000000000000
+|A 00000000000000000000000000
+|X 11100000000000000000000000
+|A 00000000000000000000000000
+|X 11100000000000000000000000
+|A 00000000000000000000000000
+|X 11100000000000000000000000
+|D 00000000000000000000000001
+|W 11100000000000000000000000
+|B 00000000000000000000000000
+|Y 11100000000000000000000000
+|B 00000000000000000000000000
+|Y 11100000000000000000000000
+|D 00000000000000000000000001
+|W 11100000000000000000000000
+|B 00000000000000000000000000
+|Y 11100000000000000000000000
+|B 00000000000000000000000000
+|Y 11100000000000000000000000
+|C 00000000000000000000000000
+|Z 11100000000000000000000000
+|C 00000000000000000000000000
+|Z 11100000000000000000000000
+|D 00000000000000000000000001
+|W 11100000000000000000000000
+|C 00000000000000000000000000
+|Z 11100000000000000000000000
+|C 00000000000000000000000000
+|Z 11100000000000000000000000
+|==STAGE 1===============================
+|Candidate routine: AY
+|    0: AX
+|    2: AX
+|    4: AX
+|    6: AX
+|   10: BY
+|   12: BY
+|   16: BY
+|   18: BY
+|   20: CZ
+|   22: CZ
+|   26: CZ
+|   28: CZ
+|----------------------------------------
+|Candidate routine: CX
+|    0: AX
+|    2: AX
+|    4: AX
+|    6: AX
+|   10: BY
+|   12: BY
+|   16: BY
+|   18: BY
+|   20: CZ
+|   22: CZ
+|   26: CZ
+|   28: CZ
+|==STAGE 2===============================
+|Candidate routine: AY
+|    0: AX
+|    2: AX
+|    4: AX
+|    6: AX
+|    8: DW
+|   10: BY
+|   12: BY
+|   14: DW
+|   16: BY
+|   18: BY
+|   20: CZ
+|   22: CZ
+|   24: DW
+|   26: CZ
+|   28: CZ
+|----------------------------------------
+|Candidate routine: CX
+|    0: AX
+|    2: AX
+|    4: AX
+|    6: AX
+|    8: DW
+|   10: BY
+|   12: BY
+|   14: DW
+|   16: BY
+|   18: BY
+|   20: CZ
+|   22: CZ
+|   24: DW
+|   26: CZ
+|   28: CZ
+|==THE END===============================
============================================
=== Submission testing ended
============================================
============================================
src/ass2.c
22:36:42_Wednesday_28_October_2020
============================================
/* Program to evaluate candidate routines for Robotic Process Automation.

  Skeleton program written by Artem Polyvyanyy, artem.polyvyanyy@unimelb.edu.au,
  September 2020, with the intention that it be modified by students
  to add functionality, as required by the assignment specification.

  Student Authorship Declaration:

  (1) I certify that except for the code provided in the initial skeleton
  file, the  program contained in this submission is completely my own
  individual work, except where explicitly noted by further comments that
  provide details otherwise.  I understand that work that has been developed
  by another student, or by me in collaboration with other students, or by
  non-students as a result of request, solicitation, or payment, may not be
  submitted for assessment in this subject.  I understand that submitting for
  assessment work developed by or in collaboration with other students or
  non-students constitutes Academic Misconduct, and may be penalized by mark
  deductions, or by other penalties determined via the University of
  Melbourne Academic Honesty Policy, as described at
  https://academicintegrity.unimelb.edu.au.

  (2) I also certify that I have not provided a copy of this work in either
  softcopy or hardcopy or any other form to any other student, and nor will I
  do so until after the marks are released. I understand that providing my
  work to other students, regardless of my intention or any undertakings made
  to me by that other student, is also Academic Misconduct.

  (3) I further understand that providing a copy of the assignment
  specification to any form of code authoring or assignment tutoring service,
  or drawing the attention of others to such services and code that may have
  been made available via such a service, may be regarded as Student General
  Misconduct (interfering with the teaching activities of the University
  and/or inciting others to commit Academic Misconduct).  I understand that
  an allegation of Student General Misconduct may arise regardless of whether
  or not I personally make use of such solutions or sought benefit from such
  actions.

   Signed by: JAMES LA FONTAINE    1079860
   Dated:     28/10/2020

*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <limits.h>
#include <string.h>

/* #define's -----------------------------------------------------------------*/

#define DEBUG 0
#if DEBUG
#define DUMP_DBL(x) printf("line %d: %s = %.6f\n", __LINE__, #x, x)
#define DUMP_INT(x) printf("line %d: %s = %d\n", __LINE__, #x, x)
#define DUMP_CHR(x) printf("line %d: %s = %c\n", __LINE__, #x, x)
#define DUMP_STR(x) printf("line %d: %s = %s\n", __LINE__, #x, x)
#define DEBUG_PRINT(x) printf("%s",x)
#else
#define DUMP_DBL(x)
#define DUMP_INT(x)
#define DUMP_CHR(x)
#define DUMP_STR(x)
#define DEBUG_PRINT(x)
#endif

#define ASIZE 26
#define LOWERCASE_OFFSET 97   /* used to line up state array with ASCII codes */

#define MUSTTRUE 1            /* indicates value must be true   */
#define EITHER 0              /* indicates either value is fine */
#define MUSTFALSE -1          /* indicates value must be false  */
#define SETTRUE 1             /* indicates value is set to true by action */   
#define SAME 0                /* indicates value is kept same by action */
#define SETFALSE -1              /* indicates value is set to false by action */
#define TRUE 1
#define FALSE 0

#define TRUEPRECON 0
#define FALSEPRECON 1
#define ACTIONNAME 2
#define TRUEEFFECT 3
#define FALSEEFFECT 4

#define NEWLINE 10            /* ASCII code for newline  */
#define HASH 35               /* ASCII code for # symbol */
#define COLON 58              /* ASCII code for : symbol */

#define VALID 1           
#define INVALID 0

#define EQUAL 1

/* type definitions ----------------------------------------------------------*/

// state (values of the 26 Boolean variables)
typedef int state_t[ASIZE];

// action
typedef struct action action_t;
struct action {
    char name;        // action name
    state_t precon;   // precondition
    state_t effect;   // effect
};

// step in a trace
typedef struct step step_t;
struct step {
    action_t *action; // pointer to an action performed at this step
    step_t   *next;   // pointer to the next step in this trace
};

// trace (implemented as a linked list)
typedef struct {
    step_t *head;     // pointer to the step in the head of the trace
    step_t *tail;     // pointer to the step in the tail of the trace
} trace_t;

/* function prototypes -------------------------------------------------------*/
trace_t* make_empty_trace(void);
trace_t* insert_at_tail(trace_t*, action_t*);
void free_trace(trace_t*);

/* my function prototypes ----------------------------------------------------*/

int mygetchar(void);
action_t* create_new_action_struct(void);

void stage0(void);
trace_t* simulate_trace(step_t*, state_t);
int validate_trace(trace_t*, trace_t*, state_t, int*);

void stage_1_and_2(trace_t*, trace_t*, int);
void print_candidate_routine(trace_t* canactions);
void print_subsequence(trace_t*, int, int);
int equal_cumulative_effect(state_t*, state_t*);
void identify_subsequences(trace_t*, trace_t*, int, int);
void create_change_array(trace_t*, state_t*);
int	is_extra_changes(trace_t*, step_t*, state_t*);

/* where it all happens ------------------------------------------------------*/
int
main(int argc, char *argv[]) {
    stage0();
    return EXIT_SUCCESS;        // we are done !!! algorithms are fun!!!
}

/* function definitions ------------------------------------------------------*/

// Adapted version of the make_empty_list function by Alistair Moffat:
// https://people.eng.unimelb.edu.au/ammoffat/ppsaa/c/listops.c
// Data type and variable names changed
trace_t
*make_empty_trace(void) {
    trace_t *R;
    R = (trace_t*)malloc(sizeof(*R));
    assert(R!=NULL);
    R->head = R->tail = NULL;
    return R;
}

/******************************************************************************/

// Adapted version of the insert_at_foot function by Alistair Moffat:
// https://people.eng.unimelb.edu.au/ammoffat/ppsaa/c/listops.c
// Data type and variable names changed
trace_t 
*insert_at_tail(trace_t* R, action_t* addr) {
    step_t *new;
    new = (step_t*)malloc(sizeof(*new));
    assert(R!=NULL && new!=NULL);
    new->action = addr;
    new->next = NULL;
    if (R->tail==NULL) { /* this is the first insertion into the trace */
        R->head = R->tail = new; 
    } else {
        R->tail->next = new;
        R->tail = new;
    }
    return R;
}

/******************************************************************************/

// Adapted version of the free_list function by Alistair Moffat:
// https://people.eng.unimelb.edu.au/ammoffat/ppsaa/c/listops.c
// Data type and variable names changed
void
free_trace(trace_t* R) {
    step_t *curr, *prev;
    assert(R!=NULL);
    curr = R->head;
    while (curr) {
        prev = curr;
        curr = curr->next;
        free(prev);
    }
    free(R);
}

/* my function definitions ---------------------------------------------------*/

int
mygetchar() {
	int c;
	while ((c=getchar())=='\r') {
	}
	return c;
}

/******************************************************************************/

/* handles all the flow of stage 0 and is the entry point into the entire 
program
*/
void
stage0() {
	trace_t *definitions = make_empty_trace();
	trace_t *trcactions = make_empty_trace();
	trace_t *simulatedtrace;
	state_t I = {FALSE};                               /* initial state array */
	action_t *newaction;
	step_t *currentdefinition, *currentnamestep, *currentstatestep;
	int currsubaction=TRUEPRECON, made_new_struct=FALSE;
	int numdefinitions=0, tracelen=0;
	int i, j, validtracelen=0;
	int *vtlp=&validtracelen;
	char ch;
	
	/* set up the initial state of the variables in an array */
	while (scanf(" %c", &ch)) {
		if (ch == HASH) {
			break;
		}
		I[ch-LOWERCASE_OFFSET] = TRUE;
	}
	
	/* create a linked list of the action definitions (probably should put into own function) */	
	while (scanf("%c", &ch)) {
		/* once we encounter a #, we are finished defining actions */
		DUMP_CHR(ch);	
		if (ch==HASH) {
			break;
		/* if we encounter a newline, we will now record a new action */
		}else if (ch==NEWLINE) {
			currsubaction = TRUEPRECON;
			made_new_struct = FALSE;
			continue;
		}
		/* check if we need to allocate memory for a new action struct */
		if (!made_new_struct) {
			definitions = insert_at_tail(definitions, create_new_action_struct());
			newaction = definitions->tail->action;
			made_new_struct = TRUE;
			numdefinitions += 1;
			DEBUG_PRINT("new step node created in definition list\n");
		}
		
		/* first record the true preconditions until a colon is encountered */
		if (currsubaction==TRUEPRECON) {
			if (ch==COLON) {
				currsubaction=FALSEPRECON;
				continue;
			}
			newaction->precon[ch-LOWERCASE_OFFSET] = MUSTTRUE;
			DUMP_INT(newaction->precon[ch-LOWERCASE_OFFSET]);
			
		/* now the false preconditions */
		}else if (currsubaction==FALSEPRECON) {
			if (ch==COLON) {
				currsubaction = ACTIONNAME;
				continue;
			}
			newaction->precon[ch-LOWERCASE_OFFSET] = MUSTFALSE;
			DUMP_INT(newaction->precon[ch-LOWERCASE_OFFSET]);
			
		/* now the action name */
		}else if (currsubaction==ACTIONNAME) {
			if (ch==COLON) {
				currsubaction = TRUEEFFECT;
				continue;
			}
			newaction->name = ch;
			DUMP_CHR(newaction->name);
			
		/* now the true effects */
		}else if (currsubaction==TRUEEFFECT) {
			if (ch==COLON) {
				currsubaction = FALSEEFFECT;
				continue;
			}
			newaction->effect[ch-LOWERCASE_OFFSET] = SETTRUE;
			DUMP_INT(newaction->effect[ch-LOWERCASE_OFFSET]);
		}else if (currsubaction==FALSEEFFECT) {
			newaction->effect[ch-LOWERCASE_OFFSET] = SETFALSE;
			DUMP_INT(newaction->effect[ch-LOWERCASE_OFFSET]);
		}
	}
	
	/* remove the previous newline */
	mygetchar();
	
	/* now we will read the trace and create a linked list of ordered 
	action definitions */ // (put into a function as this is used in all stages)
	while (scanf("%c", &ch)) {
		DUMP_CHR(ch);
		if (ch==HASH) {
			break;
		}else if (ch==NEWLINE) {
				break;
		}
		
		/* we must have received an action name in the input trace */
		currentdefinition = definitions->head;
		while (currentdefinition) {
			/* find the matching action in the definition list and record it in
			the ordered list */
			if (ch==currentdefinition->action->name) {
				trcactions = insert_at_tail(trcactions, currentdefinition->action);
				DEBUG_PRINT("a new orderdef definition has been inserted\n");
				tracelen += 1;
				DUMP_INT(trcactions->tail->action->precon[0]);
				DUMP_INT(trcactions->tail->action->precon[1]);
				DUMP_INT(trcactions->tail->action->precon[2]);
				break;				
			/* otherwise we haven't found the matching action and need to keep 
			looking */
			}else {
				currentdefinition = currentdefinition->next;
				DEBUG_PRINT("no match here, looking at next definition\n");
			}
		}
	}
	
	/* using the ordered definitions list we will now simulate the
	trace and record all the states along the way so we can display them */
	simulatedtrace = simulate_trace(trcactions->head, I);
	
	DEBUG_PRINT("have created a simulated trace linked list\n");
	
	/* now we will display this information as specified */
	printf("==STAGE 0===============================\n");
	printf("Number of distinct actions: %d\n", numdefinitions);
	printf("Length of the input trace: %d\n", tracelen);
	if (validate_trace(simulatedtrace, trcactions, I, vtlp)) {
		printf("Trace status: valid\n");
	}else {
		printf("Trace status: invalid\n");
	}
	printf("----------------------------------------\n");
	printf("  abcdefghijklmnopqrstuvwxyz\n");
	printf("> ");
	for (i=0; i<ASIZE; i++) {
		printf("%d", I[i]);
	}
	currentnamestep = trcactions->head;
	currentstatestep = simulatedtrace->head;
	for (i=0; i<validtracelen; i++) {
		printf("\n");
		printf("%c ", currentnamestep->action->name);
		for (j=0; j<ASIZE; j++) {
			printf("%d", currentstatestep->action->effect[j]);
		}
		currentnamestep = currentnamestep->next;
		currentstatestep = currentstatestep->next;
	}
	fflush(stdout);
	free(simulatedtrace);
	if ((ch=mygetchar())==HASH) {
		/* remove newline */
		mygetchar();
		stage_1_and_2(definitions, trcactions, tracelen);
	}
	free(trcactions);
	trcactions=NULL;
	free(definitions);
	definitions=NULL;
	return;
}

/******************************************************************************/

/* mallocs a new action struct that will be inserted into linked lists 
*/
action_t
*create_new_action_struct() {
	action_t *newaction;
	int i;
	
	newaction = (action_t*)malloc(sizeof(*newaction));
	assert(newaction!=NULL);
	// DEBUG_PRINT("a newaction struct has been created\n");
	/* initialise the state arrays to a default state */
	for (i=0; i<ASIZE; i++) {
		newaction->precon[i] = EITHER;
		newaction->effect[i] = SAME;
	}
	
	return newaction;
}	

/******************************************************************************/


/* creates a linked list by simulating all the actions in the trace and storing
the resultant states in effect arrays
*/
trace_t
*simulate_trace(step_t* currenttrcstep, state_t I) {
	trace_t *simulatedtrace = make_empty_trace();
	action_t *currentaction, *prevaction;
	int i, simtracelen=0;
	
	while (currenttrcstep) {
		currentaction = create_new_action_struct();
		/* we apply the first action to the initial state */
		if (simtracelen==0) {
			for (i=0; i<ASIZE; i++) {
				// DUMP_INT(currenttrcstep->action->effect[i]);
				/* check if action definition says we need to change value */
				if (currenttrcstep->action->effect[i]==SETTRUE) {
					currentaction->effect[i] = TRUE;
					// DEBUG_PRINT("applied action to initial state, flip\n");
					// DUMP_INT(currentaction->effect[i]);
				}else if (currenttrcstep->action->effect[i]==SETFALSE) {
					currentaction->effect[i] = FALSE;
					// DEBUG_PRINT("applied action to initial state, no flip\n");
					// DUMP_INT(currentaction->effect[i]);
				/* otherwise it is same value as it was before the action */
				}else {
					currentaction->effect[i] = I[i];
					// DEBUG_PRINT("applied action to initial state, same\n");
					// DUMP_INT(currentaction->effect[i]);
				}
			}
		/* this isn't the first action so we apply the action to the 
		previous state */
		} else {
			for (i=0; i<ASIZE; i++) {
				/* check if action definition says we need to change value */
				if (currenttrcstep->action->effect[i]==SETTRUE) {
					currentaction->effect[i] = TRUE;
					// DEBUG_PRINT("applied action to current state, true\n");
					// DUMP_INT(currentaction->effect[i]);
				}else if (currenttrcstep->action->effect[i]==SETFALSE) {
					currentaction->effect[i] = FALSE;
					// DEBUG_PRINT("applied action to current state, false\n");
					// DUMP_INT(currentaction->effect[i]);	
				/* otherwise it is same value as it was before the action */
				} else {
					currentaction->effect[i] = (prevaction->effect[i]);
					// DEBUG_PRINT("applied action to current state, same\n");
					// DUMP_INT(currentaction->effect[i]);
				}
			}
		}
		simulatedtrace = insert_at_tail(simulatedtrace, currentaction);
		simtracelen += 1;
		prevaction = currentaction;
		currenttrcstep = currenttrcstep->next;
		
	}
	return simulatedtrace;
}
	
/******************************************************************************/

/* checks that the actions occur with each state fulfilling the
precondition or, if they don't, finds out when the trace becomes invalid
*/
int
validate_trace(trace_t* simulatedtrace, trace_t* trcactions, state_t I,  
	           int* validtracelen) {
	int i;
	state_t *currentprecon, *prevstate;
	step_t *currentdefstep, *currentsimstep;
	
	DEBUG_PRINT("now attempting to validate the trace\n");
	
	/* current step in simulation list */
	currentsimstep = simulatedtrace->head;
	/* current step in ordered list of trace actions */
	currentdefstep = trcactions->head;
	
	// DEBUG_PRINT("steps and precons have been set\n");
	/* if this is the first action, we need to check its preconditions 
	with the initial state */
	while (currentsimstep) {
	assert (currentdefstep);
	currentprecon = &(currentdefstep->action->precon);
		if (*validtracelen==0) {
			// DEBUG_PRINT("validtracelen==0 so checking precons with initial\n");
			for (i=0; i<ASIZE; i++) {	
				/* check if value must be true and is actually false */
				if ((*currentprecon)[i]==MUSTTRUE && !(I[i])) {
					// DEBUG_PRINT("true value found to be false\n");
					return INVALID;
				/* check if value must be false and is actually true */
				} else if ((*currentprecon)[i]==MUSTFALSE && (I[i])) {
					// DEBUG_PRINT("false value found to be true\n");
					return INVALID;
				}
			}
		/* otherwise we are checking the previous state with the next actions
		preconditions */
		}else {
			for (i=0; i<ASIZE; i++) {
				/* check if value must be true and is actually false */
				if ((*currentprecon)[i]==MUSTTRUE && !((*prevstate)[i])) {
					// DEBUG_PRINT("true value found to be false\n");
					return INVALID;
				/* check if value must be false and is actually true */
				}else if ((*currentprecon)[i]==MUSTFALSE && (*prevstate)[i]) {
					// DEBUG_PRINT("false value found to be true\n");
					return INVALID;
				}
			}
		}
		*validtracelen += 1;
		// DEBUG_PRINT("validtracelen incremented by 1\n");
		prevstate = &(currentsimstep->action->effect);
		// DEBUG_PRINT("new prevstate set\n");
		currentsimstep = currentsimstep->next;
		// DEBUG_PRINT("new currentsimstep set\n");
		currentdefstep = currentdefstep->next;
		// DEBUG_PRINT("new steps and states set\n");
		
	}
	
	DEBUG_PRINT("all states have been verified, can return VALID\n");
	
	/* all actions occur with their preconditions fulfilled so the trace is 
	valid */
	return VALID;
}

/******************************************************************************/
/******************************************************************************/

/* entry point into stage 1, handles the input of the candidate routine and 
leads to searching for subsequences and printing them. If stage 2 is required 
then isstage1 variable is simply changed to false and the subsequence searching
function takes this into account
*/
void stage_1_and_2(trace_t* definitions, trace_t* trcactions, int tracelen) {
	/* now we will read the candidate trace and create a linked list of ordered 
	action definitions */
	trace_t* canactions = make_empty_trace();
	step_t *currentdefinition;
	int canlen = 0;             		/* length of a candidate routine */
	int firstcandidate = TRUE, firstaction = TRUE, isstage1 = TRUE;
	char ch;
	
	/* remove previous newline*/
	
	
	DEBUG_PRINT("\nnow looking at candidate routines\n");
	printf("\n==STAGE 1===============================\n");
	
	/* read the input for the candidate routine */
	while (scanf("%c", &ch)) {
		DEBUG_PRINT("reading next character ");
		DUMP_CHR(ch);
		if (ch==HASH) {
			fflush(stdout);
			isstage1 = FALSE;
			firstcandidate = TRUE;
			printf("\n==STAGE 2===============================\n");
			/* remove the newline */
			mygetchar();
		}else if (ch==NEWLINE) {
			/* we are finished reading this candidate routine and have to now 
			identify the subsequences and print them out */
			DEBUG_PRINT("newline character encountered here\n");
			DUMP_INT(canlen);
			if (canlen==0) {
				if (!isstage1) {
					free(canactions);
					canactions = NULL;
					printf("\n==THE END===============================");
					fflush(stdout);
					return;
				}
				free(canactions);
				canactions = NULL;
				return;
			}
			print_candidate_routine(canactions);
			identify_subsequences(canactions, trcactions, tracelen, isstage1);
			
			/* now have to read and make a linked list for a new candidate 
			routine */
			free(canactions);
			canactions = make_empty_trace();
			canlen = 0;
			firstcandidate = FALSE;
			firstaction = TRUE;
			
			
		/* we must have received a candidate routine action name */
		}else {
			if (firstaction && !firstcandidate) {
				printf("\n----------------------------------------\n");
				firstaction = FALSE;
			}
			currentdefinition = definitions->head;
			while (currentdefinition) { /* turn into function */
				/* find the matching action in the definition list and record it 
				in the candidate routine ordered definitions list */
				if (ch==currentdefinition->action->name) {
					canactions = insert_at_tail(canactions, 
												currentdefinition->action);
					canlen += 1;
					DEBUG_PRINT("new canactions definition inserted\n");
					break;				
				/* otherwise we haven't found the matching action and need to 
				keep looking */
				}else {
					currentdefinition = currentdefinition->next;
					DEBUG_PRINT("no match here, looking at next definition\n");
				}
			}
		}
	}
}

/******************************************************************************/	

/* checks the values of variables based on 2 given effect states and 
returns whether an equal effect was produced or not
*/
int
equal_cumulative_effect(state_t* effect1ptr, state_t* effect2ptr) {
	int i;

	for (i=0; i<ASIZE; i++) {
		if ((*effect1ptr)[i]!=(*effect2ptr)[i]) {
			return !EQUAL;
		}
	}
	return EQUAL;
}

/******************************************************************************/

/* is given an ordered list of actions and their definitions based on a 
candidate routine and a trace and finds the smallest non-overlapping 
subsequences in the trace with the same cumulative effect as the candidate 
routine
*/
void
identify_subsequences(trace_t* canactions, trace_t* trcactions, int tracelen,
	                  int isstage1) {
	trace_t *simcan, *simsubseq;
	state_t changes = {FALSE};
	state_t *changesptr = &changes;
	state_t I = {FALSE};   /* blank slate initial state for comparing effects */
	state_t *caneffectptr, *subseqeffectptr;
	step_t *subseqfirststep, *subseqeffectstep;
	int startpos, endpos;        /* current position in trace being looked at */
	int startdepth=0, enddepth=0;                /* step depth in linked list */
	int match_found=FALSE;
	
	// DEBUG_PRINT("now identifying subsequences\n");
	
	/*first we will simulate and store the cumulative effect of the candidate 
	routine */
	simcan = simulate_trace(canactions->head, I);
	assert(simcan->tail);
	caneffectptr = &(simcan->tail->action->effect);
	// DEBUG_PRINT("have made simulated candidate routine\n");
	
	/* create a change array that describes which variables are changed within
	the candidate routine if this is stage 1  */
	if (isstage1) {
		create_change_array(simcan, changesptr);
	}
	
	/* now we will iterate through the trace and find the smallest 
	subsequences that have the same cumulative effect as the candidate routine*/
	
	DEBUG_PRINT("now iterating through subsequences of the trace\n");
	/* iterate through each starting position */
	subseqfirststep = trcactions->head;
	for (startpos=0; startpos<tracelen;) {
		// DUMP_INT(startpos);
		/* line up what will be the first action in the subsequence simulation 
		with the current action we are up to in the subsequence search */
		for (; startdepth<startpos; startdepth++) {
			subseqfirststep = subseqfirststep->next;
		//	DEBUG_PRINT("startdepth was less than startpos and was shifted\n");
		}
		/* create a simulation of a full sequence of trace actions starting 
		from the first step and ending at the end of the trace, we will use the 
		last step variable to pinpoint the appropriate cumulative effect */
		simsubseq = simulate_trace(subseqfirststep, I);
			
		
		/* iterate through all subsequences of the trace starting from startpos 
		*/
		for (endpos=startpos; endpos<tracelen; endpos++) {
			// DUMP_INT(endpos);
			/* have to go the current 'last' step in the subsequence's 
			simulation specified by the endpos to find and store its cumulative 
			effect */
			subseqeffectstep = simsubseq->head;
			subseqeffectptr = &(subseqeffectstep->action->effect);
			for (enddepth=startdepth; enddepth<endpos; enddepth++) { 
				subseqeffectstep = subseqeffectstep->next;
				subseqeffectptr = &(subseqeffectstep->action->effect);
			//	DEBUG_PRINT("the subsequent effect pointer has been moved\n");
			}
			/* check if the subsequence achieves the same cumulative effect
			as the candidate routine */
			if (equal_cumulative_effect(caneffectptr, subseqeffectptr)) {
				/* subsequence can't change any extra variables for stage 1 */
				if (is_extra_changes(simsubseq, subseqeffectstep, changesptr) 
					&& isstage1) {
					continue;
				}
				DEBUG_PRINT("a matching subsequence has been found\n");
				print_subsequence(trcactions, startpos, endpos);
				match_found = TRUE;
				break;
			}
		}
		/* if we found a match then restart the search from 1 to the right of
		the endpos, or if we didn't find anything then just shift by 1*/
		if (match_found) {
			startpos = endpos+1;
			match_found = FALSE;
			free(simsubseq);
			simsubseq = NULL;
		}else { 
			startpos += 1;
			free(simsubseq);
			simsubseq = NULL;
		}
	}
	free(simcan);
	simcan = NULL;
	return;
}

/******************************************************************************/
/* prints out the line for a candidate routine including the action names 
*/
void
print_candidate_routine(trace_t* canactions) {
	step_t *currentstep;
	
	printf("Candidate routine: ");
	currentstep = canactions->head;
	/* print out each action name in our candidate routine ordered actions list 
	*/
	while (currentstep) {
		printf("%c", currentstep->action->name);
		currentstep = currentstep->next;
	}
	
	return;
}

/******************************************************************************/
/* prints out the line for a subsequence including the action names and position
in the trace that the subsequence begins at
*/
void
print_subsequence(trace_t* trcactions, int startpos, 
			      int endpos) {
	int trcdepth;
	step_t *currentstep;
	
	printf("\n");
	printf("%5d: ", startpos);
	currentstep = trcactions->head;
	/* we get the action names from the original ordered trace actions list
	and use startpos and endpos as our guides to find the right actions */
	for (trcdepth = 0; trcdepth<startpos; trcdepth++) {
		currentstep = currentstep->next;
	}
	/* print out each action name in our simulated subsequence (which has been
	found to produce the cumulative effect of the candidate routine)
	*/
	for (;startpos<=endpos; startpos++) {
		printf("%c", currentstep->action->name);
		currentstep = currentstep->next;
	}
	
	return;
}

/******************************************************************************/

/* creates an array of the 26 variables with a value 1 indicating that the
value is changed by the candidate routine and 0 indicating it is untouched */
void
create_change_array(trace_t* simcan, state_t* changes) {
    step_t *currentstep;
    int i;
   
    currentstep = simcan->head;
    while (currentstep) {
    	for (i=0; i<ASIZE; i++) {
    		/* if a value is ever set/modified by an action in the candidate
    		routine, the change array will denote this with a TRUE value */
    		if (currentstep->action->effect[i]!=SAME) {
    			(*changes)[i] = TRUE;
    		}
    	}
    	currentstep = currentstep->next;
    }
    
    return;
}

/******************************************************************************/

/* checks to see if a subsequence changes any values that are not touched by
the candidate routine and therefore if the subsequence does not match in the 
case of stage 1
*/
int	
is_extra_changes(trace_t* simsubseq, step_t* subseqeffectstep, 
				 state_t* changes) {
	step_t *currentstep;
	int i;
	
	/* if changes array indicates that a value isn't changed in the candidate
	routine, then in the simulated subsequence it should be false at all stages
	as the initial state we start with in our testing is an all false state */
	currentstep = simsubseq->head;
	/* we check each effect state until the end of the subsequence which is 
	represented by the step after subseqeffectstep */
	while (currentstep!=subseqeffectstep->next) {
		for (i=0; i<ASIZE; i++) {
			if ((*changes)[i]==FALSE && currentstep->action->effect[i]!=FALSE) {
				return TRUE;
			}
		}
		currentstep = currentstep->next;
	}
	/* if we have made it here, then the subsequence hasn't changed any 
	variables that the candidate routine doesn't change */
	return FALSE;
}

/******************************************************************************/	
/* --------------------------  ta-da-da-daa!!! ------------------------------ */
/******************************************************************************/
/* -------------------------- algorithms are fun ---------------------------- */   
/******************************************************************************/